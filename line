src/parser/autocompletion.c:	add_to_line(&shell->line, to_add);
src/parser/autocompletion.c:	if (first_arg(shell->line.data))
src/parser/autocompletion.c:		if (!word_to_complete(shell->line.data))
src/parser/autocompletion.c:			word = shell->line.data;
src/parser/autocompletion.c:			word = word_to_complete(shell->line.data) + 1;
src/parser/autocompletion.c:		word = word_to_complete(shell->line.data) + 1;
src/parser/fill_line.c:	if (!shell->line.data)
src/parser/fn_keys.c:	i = shell->line.cursor;
src/parser/fn_keys.c:	if (shell->line.cursor < shell->line.len)
src/parser/fn_keys.c:		while (shell->line.data[i] != ' ' && i < shell->line.len)
src/parser/fn_keys.c:	i = shell->line.cursor;
src/parser/fn_keys.c:	if (shell->line.cursor > 0)
src/parser/fn_keys.c:		while (shell->line.data[i] != ' ' && i > 0)
src/parser/fn_keys.c:		while (shell->line.data[i] != ' ' && i > 0)
src/parser/fn_keys.c:		if (shell->line.cursor > 0)
src/parser/history.c:	while (shell->line.cursor < shell->line.len)
src/parser/history.c:	while (shell->line.cursor > 0)
src/parser/history.c:	if (!(curr = shell->history))
src/parser/history.c:	if (shell->his_pos > -1)
src/parser/history.c:		shell->his_pos--;
src/parser/history.c:	while (i < shell->his_pos && curr)
src/parser/history.c:	if (shell->his_pos > -1)
src/parser/history.c:		shell->line.cursor = curr->content_size - 1;
src/parser/history.c:		free_line(&shell->line);
src/parser/history.c:		shell->line.data = ft_strdup(curr->content);
src/parser/history.c:		shell->line.len = curr->content_size - 1;
src/parser/history.c:		shell->line.alloc_size = curr->content_size;
src/parser/history.c:	if (!(curr = shell->history))
src/parser/history.c:	if (shell->his_pos < (int)ft_lstlen(shell->history) - 1)
src/parser/history.c:		shell->his_pos++;
src/parser/history.c:	while (i < shell->his_pos && curr->next)
src/parser/history.c:	free_line(&shell->line);
src/parser/history.c:	shell->line.data = ft_strdup(curr->content);
src/parser/history.c:	shell->line.len = curr->content_size - 1;
src/parser/history.c:	shell->line.alloc_size = curr->content_size;
src/parser/history.c:	ft_printf("%s", shell->line.data);
src/parser/history.c:	shell->line.cursor = curr->content_size - 1;
src/parser/keys.c:	if (shell->line.cursor > 0)
src/parser/keys.c:		shell->line.cursor--;
src/parser/keys.c:	if (shell->line.cursor < shell->line.len)
src/parser/keys.c:		shell->line.cursor++;
src/parser/keys.c:	if (shell->line.cursor > 0)
src/parser/keys.c:		if (shell->line.cursor < shell->line.len)
src/parser/keys.c:			ft_del_char(shell->line.data, shell->line.cursor - 1);
src/parser/keys.c:			shell->line.data[shell->line.cursor - 1] = 0;
src/parser/keys.c:			shell->line.len--;
src/parser/keys.c:		shell->line.cursor--;
src/parser/keys.c:	while (shell->line.cursor > 0)
src/parser/keys.c:	while (shell->line.cursor < shell->line.len)
src/parser/lexer.c:		if (shell->line.data[pos] >= 0)
src/parser/lexer.c:			ret = shell->lexer.lexer_actions[shell->lexer.lss->state]
src/parser/lexer.c:				[(int)shell->line.data[pos]](shell, current,
src/parser/lexer.c:						shell->line.data[pos]);
src/parser/lexer.c:			if (handle_ret(&shell->lexer, ret, &current, &output))
src/parser/lexer.c:			clean_exit(&shell->lexer, &output, &current, SYNTAX_ERROR_MSG);
src/parser/lexer_act.c:	lss_pop(&shell->lexer);
src/parser/lexer_act.c:	if (lss_push(&shell->lexer, LSTATE_WORD))
src/parser/lexer_act.c:	lss_pop(&shell->lexer);
src/parser/lexer_act_meta.c:		lss_pop(&shell->lexer);
src/parser/lexer_act_meta.c:	if (lss_push(&shell->lexer, LSTATE_META))
src/parser/lexer_act_meta.c:		shell->lexer.lss->state = LSTATE_META;
src/parser/lexer_act_meta.c:	lss_pop(&shell->lexer);
src/parser/lexer_act_quote.c:	if (lss_push(&shell->lexer, LSTATE_DQUOTE))
src/parser/lexer_act_quote.c:	if (lss_push(&shell->lexer, LSTATE_SQUOTE))
src/parser/lexer_act_var.c:	if (lss_push(&shell->lexer, LSTATE_VAR))
src/parser/lexer_act_var.c:	lss_pop(&shell->lexer);
src/parser/tools_keys.c:	if (add_to_line(&shell->line, buf))
